/*
 * UTNBilbiotecaTomaDeDatos.c
 *
 *  Created on: 13 may 2022
 *      Author: ludmi
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int esNumerica(char* cadena);
static int getInt(int* pResultado);
static int esFlotante(char* cadena);
static int getFloat(float* pResultado);
static int esUnArrayDeChar(char * cadena, int longitud);


int utn_getCaracter(char * pResultado, char* mensaje, char * mensajeError, char minimo, char maximo, int reintentos)
{
	int retorno;
	char auxiliar;
	retorno = -1;

	if (pResultado !=NULL && mensaje !=NULL && mensajeError !=NULL && minimo <= maximo && reintentos >=0){

		do {
         printf("%s",mensaje);
		scanf("%c",&auxiliar);
		 if (auxiliar >=minimo && auxiliar <=maximo)
		 {
			 *pResultado = auxiliar;
			 retorno = 0;


		 }else {
			 printf("%s", mensajeError);
			 reintentos--;
		 }
		} while(reintentos >=0);

	}//cierre if punteros


    return  retorno;

}

/// @fn int getInt(int*, char*, char*, int, int, int)
/// @brief Solicita un numero  de tipo entero  al usuario, luego de verificarlo devuelve el resultado
///
/// @param pNumeroIngresado Puntero al espacio de memoria donde se dejara el resultado de la funcion
/// @param mensaje Es el mensaje a ser mostrado
/// @param mensajeError Es el mensaje de Error a ser mostrado
/// @param maximo Es el numero maximo a ser aceptado
/// @param minimo Es el numero maximo a ser aceptado
///
/// @param maximoDeReintentos cantidad maxima de posibilidades antes de mostrar el mensaje error
/// @return  Retorna 0 si se obtuvo el numero y -1 si no
int utn_getNumero(int * pNumeroIngresado,char * mensaje,char * mensajeError,
		int maximo, int minimo, int maximoDeReintentos){

	int buffer;
	int retorno;
	retorno = -1;

	if(pNumeroIngresado != NULL && maximo >= minimo && maximoDeReintentos>= 0){
		do{
			printf("%s", mensaje);
			//scanf("%d", &auxNumeroIngresado);
			if(getInt(&buffer) == 0 && buffer >=minimo && buffer <=maximo){
			maximoDeReintentos--;

						*pNumeroIngresado = buffer;
						retorno = 0;
						break;
			}else{
				printf("%s", mensajeError);
			}

		}while(maximoDeReintentos > 0);
	}

	return retorno;
}



int myGets(char* cadena, int longitud)
{
	fflush(stdin);
	fgets(cadena,longitud,stdin);
    cadena[strlen(cadena)-1]='\0';

	return -1;
}



static int getInt (int*pResultado)
{
    int retorno=-1;
    char buffer[4050];
    myGets(buffer,sizeof(buffer));


    scanf("%s",buffer);

    if( myGets(buffer,sizeof(buffer)) ==0  && esNumerica(buffer)){
    	retorno = 0;
    	*pResultado = atoi(buffer);

    }
    return retorno;
}


static int esNumerica(char* cadena)
{
	int retorno = 1;
	int i = 0;

	if(cadena[0]=='-'){
		i = 1;
	}
	for ( i=0; cadena[i]!='\0';i++){

		if(cadena[i] >'9' || cadena[i]<'0' ){

			retorno = 0;
			break;
		}
	}

	return retorno;
}



static int getFloat(float* pResultado)
{
   // int retorno=-1;

   // return retorno;
    int retorno=-1;
    char buffer[4050];
    myGets(buffer,sizeof(buffer));


    scanf("%s",buffer);

    if( myGets(buffer,sizeof(buffer)) ==0  && esFlotante(buffer)){
    	retorno = 0;
    	*pResultado = atoi(buffer);

    }
    return retorno;
}




static int esFlotante(char* cadena)
{
	//int retorno = 1;
	//return retorno;
	int retorno = 1;
	int i = 0;

	if(cadena[0]=='-'){
		i = 1;
	}
	for ( i=0; cadena[i]!='\0';i++){

		if(cadena[i] >'9' || cadena[i]<'0' ){

			retorno = 0;
			break;
		}
	}

	return retorno;
}


int utn_getNumeroFlotante(float* pResultado, char* mensaje, char* mensajeError, float minimo, float maximo, int reintentos)
{
	//int retorno = -1;
   //return retorno;
	float buffer;
	int retorno;
	retorno = -1;

	if(pResultado!= NULL && maximo >= minimo && reintentos>= 0){
		do{
			printf("%s", mensaje);
			//scanf("%d", &auxNumeroIngresado);
			if(getFloat(&buffer) == 0 && buffer >=minimo && buffer <=maximo){
				reintentos--;

						*pResultado = buffer;
						retorno = 0;
						break;
			}else{
				printf("%s", mensajeError);
			}

		}while(reintentos > 0);
	}

	return retorno;
}


int isMail(char cadena[])
{
	int retorno=1;
	int i=0;
	int contadorArrobas=0;
	if(cadena!=NULL)
	{
		while(cadena[i]!='\0')
		{
		 if(cadena[i]=='@'){
				contadorArrobas++;

		  if(contadorArrobas>1){
					retorno=0;
					break;}
			      }
		 if((cadena[i]<'A' || cadena[i]>'Z') && (cadena[i]<'a' ||cadena[i]>'z')
					&& cadena[i]!='_' && cadena[i]!='-' && cadena[i]!='.' && cadena[i]!='@') {
				retorno=0;
				break;
			}
			i++;
		}
	}

	return retorno;
}

int esUnAlfanumerico(char *array){
    int i;
    int isAlphanumeric = 0;
  if (array != NULL){
      for (i = 0; i < strlen (array) - 1; i++){
	  if ((array[i] >= 'A' && array[i] <= 'Z')
	      || (array[i] >= 'a' && array[i] <= 'z')
	      || (array[i] >= '0' && array[i] <= '9')){
	      isAlphanumeric = 0;
	    }else{
	      isAlphanumeric = -1;
	      break;
	    }

	}
  }
    return isAlphanumeric;
}

/**
* \brief Solicita una cadena de caracteres al usuario y la valida
* \param input Se carga el string ingresado
* \param message Es el mensaje a ser mostrado
* \param eMessage Es el mensaje a ser mostrado en caso de error
* \param lowLimit Longitud mínima de la cadena
* \param hiLimit Longitud máxima de la cadena
* \return Si obtuvo la cadena [0] si no [-1]
*
*/
int getString(char* input,char message[],char eMessage[], int lowLimit, int hiLimit)
{
	char buffer[4090],i;
	int retorno;

	retorno = -1;
	if(input!= NULL && message !=NULL && eMessage !=NULL && lowLimit!=NULL && hiLimit!=NULL){

		for (i=0;i<5;i++)
			{
			printf("%s", message);
			scanf("%d",&v[i]);
			}


	}



}




int utn_getNumero(int * pNumeroIngresado,char * mensaje,char * mensajeError,
		int maximo, int minimo, int maximoDeReintentos){

	int buffer;
	int retorno;
	retorno = -1;

	if(pNumeroIngresado != NULL && maximo >= minimo && maximoDeReintentos>= 0){
		do{
			printf("%s", mensaje);
			//scanf("%d", &auxNumeroIngresado);
			if(getInt(&buffer) == 0 && buffer >=minimo && buffer <=maximo){
			maximoDeReintentos--;

						*pNumeroIngresado = buffer;
						retorno = 0;
						break;
			}else{
				printf("%s", mensajeError);
			}

		}while(maximoDeReintentos > 0);
	}

	return retorno;
}




static int esUnArrayDeChar(char * cadena, int longitud){
	int i;
	int retorno;

	i=0;
	retorno = -1;
	if(cadena != NULL && longitud >0){
		for(i=0; cadena[i]!= '\0' && i <longitud; i++){
			if((cadena[i] < 'A' || cadena [i] > 'Z') && ((cadena[i] < 'a' || cadena [i] > 'z') )){

				retorno = 0;
				break;
			}
		}
	}
	return retorno;

}
